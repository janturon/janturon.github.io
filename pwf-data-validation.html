<meta charset="UTF-8">
<link rel="stylesheet" href="src/style.css">

<h1>PWF: Server-side form autovalidation</h1>
<p>The daunting task of most real-world user interaction is to code data-validation, oftentimes on multiple places using multiple languages, typically:
<ul>
  <li>Client-side: preventing user to send invalid information (outbound control)
  <li>Webserver-side: checking the inbound data (client can bypass client-side control).
  <li>DBserver-side: checking the data consistency with other data.
</ul>

<p>In the 20th century, javascript was used for client side and php for server side. In the early 21st century, most of the client-side control is done in HTML5 and this PWT module provides a way to extend it to the server side

<h2>Verbal interface description</h2>
<ol>
  <li>The data types are sent via HTTP POST to the server by type-decorating the data name in format <tt>type:name</tt>; the type can be hardcoded or generated by javascript from input attributes like <tt>min</tt>, <tt>type</tt>, <tt>required</tt> or <tt>pattern</tt>.
  <li>The server performs the check requested by client. To avoid spoofing, the server also checks md5 hash calculated from type-decorated names.
</ol>

<h2>Data types definition</h2>
<p>Servers oftentimes define their own data types and rules. The default base type definition is proposed in the format
 <tt>&lt;P>[&lt;from>][to&lt;to>][&lt;value>]</tt>, with these symbols definition:
<ul>
  <li>char <b>P</b> I=integer, N=natural, F=float, S=string, C=CSV, R=regex; lowercase (infs) means falsy values allowed
  <li>int <b>from</b> for INF minimal numeric value, for S minimal string length, for CR not applicable
  <li>int <b>to</b>   for INF maximal numeric value, for S maximal string length, for CR not applicable
  <li>string <b>value</b> for INFS not applicable, for C comma separated allowed values, for R regex to match against
</ul>

<h2>Client-side interface</h2>
<p>The client side will provide a function to type-decorate the form names:
<ul>
  <li>if the input has no name, it must not be created
  <li>if the input name contains <tt>:</tt>, it must not be decorated
  <li>if the input attribute <tt>novalidate</tt> is set, the <tt>name</tt> attribute must not be decorated
  <li>if the input type is <tt>number</tt> or <tt>range</tt>, then the <b>P</b> must be set to I, N or F
  <li>if the input attribute <tt>step</tt> is set to decimal value, the <b>P</b> must be set to F
  <li>the input attributes <tt>min</tt> and <tt>max</tt> must project to <b>from</b> and <b>to</b> respectively
  <li>the input attributes <tt>minlength</tt> and <tt>maxlength</tt> must project to <b>from</b> and <b>to</b> respectively
  <li>if the input attribute <tt>pattern</tt> is set, then the <b>P</b> must be set to R and the <b>value</b> to the pattern attribute
  <li>if the input attribute <tt>required</tt> is set, then the <b>P</b> value must be uppercase; if the attribute is not set and the <b>P</b> is not R, it must be lowercase
  <li>if the attribute type is <tt>checkbox</tt> or <tt>radio</tt>, then the <b>P</b> must be set to C and the <b>value</b> to the possible values from inputs with the same name
</ul>

<p>Possible implementation in <a href="src/serverValidate.js">serverValidate()</a> function can be used like this:
<xmp>
<form method="post" onsubmit="serverValidate(this)">
  <input type="text" name="login" placeholder="login" required>
  <input type="password" name="pass" placeholder="password" minlength="6">
  <button type="submit" name="form" value="signIn">Sign In</button>
</form>
</xmp>

<h2>Server-side interface</h2>
<p>The server side will provide following functionality:
<ul>
  <li>if the POST key contains <tt>:</tt>, it will split in two parts (type, name) using the first <tt>:</tt>, perform the type check and store the verified result somewhere using the name key
  <li>if the verification doesn't pass, it will return object or array containing members (code, form, ip, time, key, val), where code=1, form=POST form value, ip=client's IP, time=unix timestamp of the request, key=original type-decorated POST name, val=respective POST value
  <li>the server will provide functionality for optional form hash check (hash stored on the server side); if the check doesn't pass, it will return object or array containing members (code, form, ip, time, hash), where code=2, hash=calculated form hash, and form, ip, time with the same meaning as above
</ul>

<p>Possible implementation in <a href="src/form.php">FORM()</a> function can be used like this:
<xmp>
<?php
if($status=FORM("signIn", "login", "pass", "ed54378776bca02f8d5fd984f34475b4")) {
  // throws Guarantee exception with code PWF_INVALID_REQUEST if data not valid
  userLogin($login, $pass);
}
?>
</xmp>
<p>In the example, the <tt>signIn</tt> is the name of the form we want to test, followed by <tt>login</tt> and <tt>pass</tt> POST data, which the FORM function validates as the client defines (the last parameter is md5 hash preventing spoofed validation). If the form doesn't validate, assumed controller's function <tt>invalidForm()</tt> is called with tracking information. Requested POST data are exported into global context (this might be inappropriate in some environment, therefore only the interface is specified and the implementation can be adjusted to fit). <tt>userLogin()</tt> function with its params is called only if login is not empty and password is at least 6 characters long.
